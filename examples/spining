#include <iostream>
#include<vector>
#include<cmath>
#include<fstream>
#include<string>
#include<E:\eigen\Eigen/Dense>
#include<E:\eigen\Eigen/LU>
#include<E:\eigen\Eigen/Eigenvalues>

typedef Eigen::Matrix<double,3,1> vec3;
typedef Eigen::Matrix<double,3,3> mat33;

mat33 crossProductMat(const vec3& vec)
{
    mat33 mat;
    mat<<.0,-vec(2),vec(1),
        vec(2),.0,-vec(0),
        -vec(1),vec(0),.0;
    return mat;
}

mat33 getMatrix(vec3 vec, double alpha)
{
    mat33 res;

    vec.normalize();
    mat33 E=crossProductMat(vec);
    //std::cout<<vec.transpose()<<"\n";
    res=cos(alpha)*mat33::Identity()+(1-cos(alpha))*vec*vec.transpose()-sin(alpha)*E;
    return res;
}

void print(vec3& vec)
{
    std::cout<<vec(0)<<"i+"<<vec(1)<<"j+"<<vec(2)<<"k\t";
}

double length(vec3& vec)
{
    return pow(vec(0)*vec(0)+vec(1)*vec(1)+vec(2)*vec(2),.5);
}

int main()
{
    mat33 tensor;
    tensor<<80.0,.0,.0,
            .0,40.0,.0,
            .0,.0,12.0;

    vec3 omega;
    omega<<.0,1.0,.0;

    vec3 angularM=tensor*omega;
    double t=.0,dt=.000001;

    mat33 A;

    print(omega);
    print(angularM);
    std::cout<<"\n";
    std::cout<<omega.transpose()*tensor*omega<<"\n";
    for(int i=0;i<500;++i){



        A=getMatrix(omega,length(omega)*dt);
        //std::cout<<A<<"\n";
        tensor=A.transpose()*tensor*A;
        omega=tensor.inverse()*angularM;
        //std::cout<<tensor<<"\n";
        print(omega);
        print(angularM);
        std::cout<<omega.transpose()*tensor*omega<<"\n";
        t+=dt;
    }
    std::cout<<omega.transpose()*tensor*omega<<"\n";
    return 0;
}
